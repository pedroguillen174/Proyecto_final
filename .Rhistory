p.mat = p_matrix,
sig.level = 0.05,
insig = "blank",
title = "Matriz de Correlación: Score de Vulnerabilidad vs. Variables Climáticas"
)
df_top_vulnerabilidad <- mapa_vulnerabilidad_cortado %>%
sf::st_drop_geometry() %>%
dplyr::select(CVE_ENT, NOM_ENT, NOM_MUN, SCORE_VULNERABILIDAD_FINAL) %>%
na.omit() %>%
# Ordenar por Score de Vulnerabilidad Final descendente
dplyr::arrange(desc(SCORE_VULNERABILIDAD_FINAL))
head(mapa_vulnerabilidad_municipal$CVE_MUN)
mapa_vulnerabilidad_municipal <- mapa_vulnerabilidad_municipal %>%
dplyr::mutate(
# Extrae los dos primeros caracteres de la clave municipal (CVE_MUN)
# Esto genera la clave de entidad (ej., "09" de "09001", "15" de "15001")
CVE_ENT = str_sub(CVE_MUN, 1, 2)
)
# Comprobación de que la nueva columna existe
cat("Claves de entidad creadas y primeras 6: \n")
head(mapa_vulnerabilidad_municipal$CVE_ENT)
df_top_vulnerabilidad <- mapa_vulnerabilidad_cortado %>%
sf::st_drop_geometry() %>%
dplyr::select(CVE_ENT, NOM_ENT, NOM_MUN, SCORE_VULNERABILIDAD_FINAL) %>%
na.omit() %>%
# Ordenar por Score de Vulnerabilidad Final descendente
dplyr::arrange(desc(SCORE_VULNERABILIDAD_FINAL))
mapa_vulnerabilidad_municipal <- mapa_vulnerabilidad_municipal %>%
dplyr::mutate(
# Extrae los dos primeros caracteres de la clave municipal (CVE_MUN)
# Esto genera la clave de entidad (ej., "09" de "09001", "15" de "15001")
CVE_ENT = str_sub(CVE_MUN, 1, 2)
)
# Comprobación de que la nueva columna existe
cat("Claves de entidad creadas y primeras 6: \n")
head(mapa_vulnerabilidad_municipal$CVE_ENT)
df_top_vulnerabilidad <- mapa_vulnerabilidad_cortado %>%
sf::st_drop_geometry() %>%
dplyr::select(CVE_ENT, NOM_ENT, NOM_MUN, SCORE_VULNERABILIDAD_FINAL) %>%
na.omit() %>%
# Ordenar por Score de Vulnerabilidad Final descendente
dplyr::arrange(desc(SCORE_VULNERABILIDAD_FINAL))
library(stringr)
mapa_vulnerabilidad_municipal <- mapa_vulnerabilidad_municipal %>%
dplyr::mutate(
# Extrae los dos primeros caracteres de la clave municipal (CVE_MUN)
# Esto genera la clave de entidad (ej., "09" de "09001", "15" de "15001")
CVE_ENT = str_sub(CVE_MUN, 1, 2)
)
# Comprobación de que la nueva columna existe
cat("Claves de entidad creadas y primeras 6: \n")
head(mapa_vulnerabilidad_municipal$CVE_ENT)
df_top_vulnerabilidad <- mapa_vulnerabilidad_cortado %>%
sf::st_drop_geometry() %>%
dplyr::select(CVE_ENT, NOM_ENT, NOM_MUN, SCORE_VULNERABILIDAD_FINAL) %>%
na.omit() %>%
# Ordenar por Score de Vulnerabilidad Final descendente
dplyr::arrange(desc(SCORE_VULNERABILIDAD_FINAL))
# 🛑 PASO 1: CREAR LA COLUMNA CVE_ENT 🛑
df_top_vulnerabilidad <- mapa_vulnerabilidad_cortado %>%
sf::st_drop_geometry() %>%
# Crear la clave de entidad (CVE_ENT) extrayendo los dos primeros dígitos de CVE_MUN
dplyr::mutate(
CVE_ENT = str_sub(CVE_MUN, 1, 2)
) %>%
# Seleccionar las columnas necesarias, incluyendo la nueva CVE_ENT
dplyr::select(CVE_ENT, NOM_ENT, NOM_MUN, SCORE_VULNERABILIDAD_FINAL) %>%
na.omit() %>%
# Ordenar por Score de Vulnerabilidad Final descendente
dplyr::arrange(desc(SCORE_VULNERABILIDAD_FINAL))
# --- A. Top 10 Estado de México (CVE_ENT == "15") ---
top10_edomex <- df_top_vulnerabilidad %>%
dplyr::filter(CVE_ENT == "15") %>%
head(10) %>%
# Reordenar el factor NOM_MUN por el Score para la gráfica
dplyr::mutate(NOM_MUN = forcats::fct_reorder(NOM_MUN, SCORE_VULNERABILIDAD_FINAL))
# --- B. Top 10 Ciudad de México (CVE_ENT == "09") ---
top10_cdmx <- df_top_vulnerabilidad %>%
dplyr::filter(CVE_ENT == "09") %>%
head(10) %>%
# Reordenar el factor NOM_MUN por el Score para la gráfica
dplyr::mutate(NOM_MUN = forcats::fct_reorder(NOM_MUN, SCORE_VULNERABILIDAD_FINAL))
g6_top10_edomex <- top10_edomex %>%
ggplot(aes(x = NOM_MUN, y = SCORE_VULNERABILIDAD_FINAL, fill = SCORE_VULNERABILIDAD_FINAL)) +
geom_col() +
scale_fill_viridis_c(option = "inferno", guide = "none") +
coord_flip() +
labs(
title = "🔴 Top 10 Municipios con Mayor Vulnerabilidad (Estado de México)",
subtitle = "Score Final (Integración de Riesgos Biológicos, Socioeconómicos y CA)",
x = "Municipio",
y = "Score de Vulnerabilidad (0 - 1)"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
axis.text.y = element_text(size = 10)
)
print(g6_top10_edomex)
g7_top10_cdmx <- top10_cdmx %>%
ggplot(aes(x = NOM_MUN, y = SCORE_VULNERABILIDAD_FINAL, fill = SCORE_VULNERABILIDAD_FINAL)) +
geom_col() +
scale_fill_viridis_c(option = "inferno", guide = "none") +
coord_flip() +
labs(
title = "🔴 Top 10 Demarcaciones con Mayor Vulnerabilidad (Ciudad de México)",
subtitle = "Score Final (Integración de Riesgos Biológicos, Socioeconómicos y CA)",
x = "Demarcación/Alcaldía",
y = "Score de Vulnerabilidad (0 - 1)"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
axis.text.y = element_text(size = 10)
)
print(g7_top10_cdmx)
df_diagnostico <- mapa_vulnerabilidad_cortado %>%
sf::st_drop_geometry() %>%
dplyr::mutate(
CVE_ENT = str_sub(CVE_MUN, 1, 2)
) %>%
dplyr::select(CVE_ENT, NOM_ENT, NOM_MUN, SCORE_VULNERABILIDAD_FINAL)
# 2. Verificar el número de NAs en las columnas críticas
cat("Conteo de NAs por columna:\n")
sapply(df_diagnostico, function(x) sum(is.na(x)))
# 3. ¿Cuántas filas en total hay?
cat(paste("Total de filas en el objeto recortado (antes de NA omit):", nrow(df_diagnostico), "\n"))
df_diagnostico <- mapa_vulnerabilidad_cortado %>%
sf::st_drop_geometry() %>%
dplyr::mutate(
CVE_ENT = str_sub(CVE_MUN, 1, 2)
) %>%
dplyr::select(CVE_ENT, NOM_ENT, NOM_MUN, SCORE_VULNERABILIDAD_FINAL)
# 2. Verificar el número de NAs en las columnas críticas
cat("Conteo de NAs por columna:\n")
sapply(df_diagnostico, function(x) sum(is.na(x)))
# 3. ¿Cuántas filas en total hay?
cat(paste("Total de filas en el objeto recortado (antes de NA omit):", nrow(df_diagnostico), "\n"))
# --- 1. CONFIGURACIÓN DE PROYECCIÓN ESTÁNDAR ---
# La mayoría de los datos geográficos se representan en WGS 84 (EPSG: 4326)
CRS_ESTANDAR <- 4326
# --- 2. PREPARACIÓN Y LIMPIEZA DE LA MÁSCARA DE ENTIDADES ---
ruta_shp_entidades <- "D:/Introducción a R/Proyecto_final/00ent.shp"
entidades_shp <- sf::st_read(ruta_shp_entidades)
# Filtrar, limpiar y asegurar la proyección
poligonos_cdmx_edomex <- entidades_shp %>%
sf::st_transform(crs = CRS_ESTANDAR) %>% # Estandarizar proyección
dplyr::mutate(CVE_ENT = as.character(CVE_ENT)) %>%
dplyr::filter(CVE_ENT %in% c("09", "15"))
mascara_corte <- poligonos_cdmx_edomex %>%
sf::st_union()
# --- 3. PREPARACIÓN Y LIMPIEZA DEL MAPA MUNICIPAL ---
# Asegurar que el mapa de vulnerabilidad final esté en la misma proyección
mapa_vulnerabilidad_limpio <- mapa_vulnerabilidad_final_clean %>%
sf::st_transform(crs = CRS_ESTANDAR) # Estandarizar proyección
# a) Crear los centroides (puntos centrales) del mapa municipal
centroides_municipales <- mapa_vulnerabilidad_limpio %>%
sf::st_centroid()
# b) Identificar qué centroides caen DENTRO de la máscara (st_within)
# Esto no requiere intersección perfecta de bordes
municipios_a_mantener <- centroides_municipales[mascara_corte, op = st_within]
# c) Filtrar el mapa de vulnerabilidad original usando los índices de los centroides
mapa_vulnerabilidad_cortado <- mapa_vulnerabilidad_limpio[municipios_a_mantener, ]
# -----------------------------------------------------------
# DIAGNÓSTICO FINAL (debe ser > 0)
cat(paste("Total de filas en el objeto recortado (después de CRS/Centroide):",
nrow(mapa_vulnerabilidad_cortado), "\n"))
library(stringr)
# 🛑 CREACIÓN DE CLAVE ESTATAL Y TOPS (CONTINUACIÓN) 🛑
df_top_vulnerabilidad <- mapa_vulnerabilidad_cortado %>%
sf::st_drop_geometry() %>%
dplyr::mutate(
# La clave de entidad se crea a partir de los dos primeros dígitos de CVE_MUN
CVE_ENT = str_sub(CVE_MUN, 1, 2)
) %>%
# Usamos las columnas de nombre existentes (NOM_ENT, NOM_MUN)
dplyr::select(CVE_ENT, NOM_ENT, NOM_MUN, SCORE_VULNERABILIDAD_FINAL) %>%
na.omit() %>%
dplyr::arrange(desc(SCORE_VULNERABILIDAD_FINAL))
# --- A. Top 10 Estado de México (CVE_ENT == "15") ---
top10_edomex <- df_top_vulnerabilidad %>%
dplyr::filter(CVE_ENT == "15") %>%
head(10) %>%
dplyr::mutate(NOM_MUN = forcats::fct_reorder(NOM_MUN, SCORE_VULNERABILIDAD_FINAL))
# --- B. Top 10 Ciudad de México (CVE_ENT == "09") ---
top10_cdmx <- df_top_vulnerabilidad %>%
dplyr::filter(CVE_ENT == "09") %>%
head(10) %>%
dplyr::mutate(NOM_MUN = forcats::fct_reorder(NOM_MUN, SCORE_VULNERABILIDAD_FINAL))
g6_top10_edomex <- top10_edomex %>%
ggplot(aes(x = NOM_MUN, y = SCORE_VULNERABILIDAD_FINAL, fill = SCORE_VULNERABILIDAD_FINAL)) +
geom_col() +
scale_fill_viridis_c(option = "inferno", guide = "none") +
coord_flip() +
labs(
title = "🔴 Top 10 Municipios con Mayor Vulnerabilidad (Estado de México)",
subtitle = "Score Final (Integración de Riesgos Biológicos, Socioeconómicos y CA)",
x = "Municipio",
y = "Score de Vulnerabilidad (0 - 1)"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
axis.text.y = element_text(size = 10)
)
print(g6_top10_edomex)
print(g7_top10_cdmx)
g7_top10_cdmx <- top10_cdmx %>%
ggplot(aes(x = NOM_MUN, y = SCORE_VULNERABILIDAD_FINAL, fill = SCORE_VULNERABILIDAD_FINAL)) +
geom_col() +
scale_fill_viridis_c(option = "inferno", guide = "none") +
coord_flip() +
labs(
title = "🔴 Top 10 Demarcaciones con Mayor Vulnerabilidad (Ciudad de México)",
subtitle = "Score Final (Integración de Riesgos Biológicos, Socioeconómicos y CA)",
x = "Demarcación/Alcaldía",
y = "Score de Vulnerabilidad (0 - 1)"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
axis.text.y = element_text(size = 10)
)
print(g7_top10_cdmx)
g7_top10_cdmx <- top10_cdmx %>%
ggplot(aes(x = NOM_MUN, y = SCORE_VULNERABILIDAD_FINAL, fill = SCORE_VULNERABILIDAD_FINAL)) +
geom_col() +
scale_fill_viridis_c(option = "inferno", guide = "none") +
coord_flip() +
labs(
title = "🔴 Top 10 Alcaldías con Mayor Vulnerabilidad (Ciudad de México)",
subtitle = "Score Final (Integración de Riesgos Biológicos, Socioeconómicos y CA)",
x = "Demarcación/Alcaldía",
y = "Score de Vulnerabilidad (0 - 1)"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
axis.text.y = element_text(size = 10)
)
g6_top10_edomex <- top10_edomex %>%
ggplot(aes(x = NOM_MUN, y = SCORE_VULNERABILIDAD_FINAL, fill = SCORE_VULNERABILIDAD_FINAL)) +
geom_col() +
scale_fill_viridis_c(option = "inferno", direction = -1 guide = "none") +
g6_top10_edomex <- top10_edomex %>%
ggplot(aes(x = NOM_MUN, y = SCORE_VULNERABILIDAD_FINAL, fill = SCORE_VULNERABILIDAD_FINAL)) +
geom_col() +
scale_fill_viridis_c(option = "inferno", direction = -1, guide = "none") +
coord_flip() +
labs(
title = "🔴 Top 10 Municipios con Mayor Vulnerabilidad (Estado de México)",
subtitle = "Score Final (Integración de Riesgos Biológicos, Socioeconómicos y CA)",
x = "Municipio",
y = "Score de Vulnerabilidad (0 - 1)"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
axis.text.y = element_text(size = 10)
)
print(g6_top10_edomex)
g7_top10_cdmx <- top10_cdmx %>%
ggplot(aes(x = NOM_MUN, y = SCORE_VULNERABILIDAD_FINAL, fill = SCORE_VULNERABILIDAD_FINAL)) +
geom_col() +
scale_fill_viridis_c(option = "inferno", direction = -1, guide = "none") +
coord_flip() +
labs(
title = "🔴 Top 10 Alcaldías con Mayor Vulnerabilidad (Ciudad de México)",
subtitle = "Score Final (Integración de Riesgos Biológicos, Socioeconómicos y CA)",
x = "Demarcación/Alcaldía",
y = "Score de Vulnerabilidad (0 - 1)"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
axis.text.y = element_text(size = 10)
)
print(g7_top10_cdmx)
library(rgbif)
library(TeachingDemos)
library(dismo)
library(biomod2)
library(sp)
library(raster)
library(usdm)
library(foreign)
library(spocc)
library(XML)
library(reshape)
library(CoordinateCleaner)
library(sf)
library(maps)
library(rnaturalearth)
library(dplyr)
library(geodata)
library(terra)
library(corrplot)
library(RColorBrewer)
library(ggplot2)
library(stringr)
library(readxl)
modelar_especie_sdm <- function(datos_especie_crudos, nombre_cientifico, my_bioclim_rasters) {
cat(paste("Limpiando y modelando:", nombre_cientifico, "\n"))
# -------------------------------------------------------------------
# 1. LIMPIEZA Y FORMATEO DE DATOS DE PRESENCIA
# -------------------------------------------------------------------
datos_presencia_limpios <- datos_especie_crudos %>%
# Filtro de BasisOfRecord, coordenadas nulas y limpieza
filter(!is.na(decimalLongitude) & !is.na(decimalLatitude)) %>%
filter(basisOfRecord %in% c("HUMAN_OBSERVATION", "PRESERVED_SPECIMEN")) %>%
distinct(decimalLatitude, decimalLongitude, .keep_all = TRUE) %>%
dplyr::rename(longitude = decimalLongitude, latitude = decimalLatitude) %>%
dplyr::select(longitude, latitude)
# Verificación de datos mínimos (usando 15 como un umbral más seguro)
if(nrow(datos_presencia_limpios) < 15) {
stop(paste("Insuficientes datos limpios para", nombre_cientifico, ". Se requieren al menos 15 registros."))
}
# -------------------------------------------------------------------
# 2. GENERACIÓN MANUAL DE PSEUDO-AUSENCIAS
# -------------------------------------------------------------------
env_coords_matrix <- terra::xyFromCell(my_bioclim_rasters, 1:terra::ncell(my_bioclim_rasters))
env_coords <- as.data.frame(env_coords_matrix)
env_coords <- env_coords[complete.cases(env_coords), ]
n_pseudo_ausencias <- 10000
pa_xy <- dplyr::sample_n(env_coords, n_pseudo_ausencias, replace = FALSE)
pa_xy <- dplyr::rename(pa_xy, longitude = x, latitude = y)
todas_las_coords <- dplyr::bind_rows(datos_presencia_limpios, pa_xy)
pres_abs <- c(rep(1, nrow(datos_presencia_limpios)), rep(0, nrow(pa_xy)))
# -------------------------------------------------------------------
# 3. FORMATEO Y MODELADO (BIOMOD2)
# -------------------------------------------------------------------
nombre_biomod <- gsub(" ", ".", nombre_cientifico)
my_biomod_data <- BIOMOD_FormatingData(
resp.var = pres_abs,
expl.var = my_bioclim_rasters,
resp.xy = todas_las_coords,
resp.name = nombre_biomod
)
my_models <- BIOMOD_Modeling(
bm.format = my_biomod_data,
modeling.id = paste0("modelo_", nombre_biomod),
models = c('RF', 'GLM', 'GAM'),
nb.rep = 3,
data.split.perc = 80,
var.import = 3 # Cálculo de importancia de variables forzado
)
# -------------------------------------------------------------------
# 4. ENSEMBLE Y PROYECCIÓN
# -------------------------------------------------------------------
my_ensemble <- BIOMOD_EnsembleModeling(
bm.mod = my_models,
models.chosen = 'all',
em.by = 'all',
em.algo = c('EMmean'),
metric.select = c('TSS'),
metric.select.thresh = 0.7 # Usar 0.6 para ser menos estricto con la calidad del modelo
)
my_ensemble_proj <- BIOMOD_EnsembleForecasting(
bm.em = my_ensemble,
proj.name = paste0('proj_', nombre_biomod),
new.env = my_bioclim_rasters
)
return(my_ensemble_proj)
}
dir.create("worldclim_data", showWarnings = FALSE)
my_bioclim_rasters <- geodata::worldclim_country(
country = "Mexico",
var = "bio",
res = 2.5,
path = "worldclim_data"
)
lista_especies <- c(
"Triatoma mexicana",
"Triatoma barberi",
"Dipetalogaster maxima",
"Meccus longipennis",
"Meccus pallidipennis",
"Baiomys musculus",
"Neotoma mexicana"
)
resultados_sdm <- list()
for (nombre in lista_especies) {
tryCatch({
cat("\n--- Iniciando:", nombre, " (Nacional) ---\n")
# 1. Descargar datos de GBIF
datos_gbif_crudos <- occ_search(
scientificName = nombre,
hasCoordinate = TRUE,
hasGeospatialIssue = FALSE
)$data
# 2. Verificación de seguridad
if (is.null(datos_gbif_crudos)) {
stop("La descarga de GBIF para esta especie no arrojó ningún dato.")
}
# 3. Llamar a la función de modelado
mapa_proyeccion <- modelar_especie_sdm(
datos_especie_crudos = datos_gbif_crudos,
nombre_cientifico = nombre,
my_bioclim_rasters = my_bioclim_rasters
)
# 4. Almacenar el mapa de proyección final
resultados_sdm[[nombre]] <- mapa_proyeccion
cat(paste("PROCESO COMPLETO y guardado para:", nombre, "\n"))
}, error = function(e) {
cat(paste("!!! ERROR al procesar", nombre, ":", conditionMessage(e), "\n"))
})
}
# Crear Función para modelado de especies
modelar_especie_sdm <- function(datos_especie_crudos, nombre_cientifico, my_bioclim_rasters) {
cat(paste("Limpiando y modelando:", nombre_cientifico, "\n"))
# -------------------------------------------------------------------
# 1. LIMPIEZA Y FORMATEO DE DATOS DE PRESENCIA
datos_presencia_limpios <- datos_especie_crudos %>%
# Filtro de BasisOfRecord, coordenadas nulas y limpieza
filter(!is.na(decimalLongitude) & !is.na(decimalLatitude)) %>%
filter(basisOfRecord %in% c("HUMAN_OBSERVATION", "PRESERVED_SPECIMEN")) %>%
distinct(decimalLatitude, decimalLongitude, .keep_all = TRUE) %>%
dplyr::rename(longitude = decimalLongitude, latitude = decimalLatitude) %>%
dplyr::select(longitude, latitude)
# Verificación de datos mínimos (usando 15 como estándar)
if(nrow(datos_presencia_limpios) < 15) {
stop(paste("Insuficientes datos limpios para", nombre_cientifico, ". Se requieren al menos 15 registros."))
}
# -------------------------------------------------------------------
# 2. GENERACIÓN MANUAL DE PSEUDO-AUSENCIAS
env_coords_matrix <- terra::xyFromCell(my_bioclim_rasters, 1:terra::ncell(my_bioclim_rasters))
env_coords <- as.data.frame(env_coords_matrix)
env_coords <- env_coords[complete.cases(env_coords), ]
n_pseudo_ausencias <- 10000
pa_xy <- dplyr::sample_n(env_coords, n_pseudo_ausencias, replace = FALSE)
pa_xy <- dplyr::rename(pa_xy, longitude = x, latitude = y)
todas_las_coords <- dplyr::bind_rows(datos_presencia_limpios, pa_xy)
pres_abs <- c(rep(1, nrow(datos_presencia_limpios)), rep(0, nrow(pa_xy)))
# -------------------------------------------------------------------
# 3. FORMATEO Y MODELADO (BIOMOD2)
nombre_biomod <- gsub(" ", ".", nombre_cientifico)
my_biomod_data <- BIOMOD_FormatingData(
resp.var = pres_abs,
expl.var = my_bioclim_rasters,
resp.xy = todas_las_coords,
resp.name = nombre_biomod
)
my_models <- BIOMOD_Modeling(
bm.format = my_biomod_data,
modeling.id = paste0("modelo_", nombre_biomod),
models = c('RF', 'GLM', 'GAM'),
nb.rep = 3,
data.split.perc = 80,
var.import = 3 # Cálculo de importancia de variables forzado
)
# -------------------------------------------------------------------
# 4. ENSAMBLE Y PROYECCIÓN
my_ensemble <- BIOMOD_EnsembleModeling(
bm.mod = my_models,
models.chosen = 'all',
em.by = 'all',
em.algo = c('EMmean'),
metric.select = c('TSS'),
metric.select.thresh = 0.7 # Usar 0.6 para ser menos estricto con la calidad del modelo
)
my_ensemble_proj <- BIOMOD_EnsembleForecasting(
bm.em = my_ensemble,
proj.name = paste0('proj_', nombre_biomod),
new.env = my_bioclim_rasters
)
return(my_ensemble_proj)
}
dir.create("worldclim_data", showWarnings = FALSE)
my_bioclim_rasters <- geodata::worldclim_country(
country = "Mexico",
var = "bio",
res = 2.5,
path = "worldclim_data"
)
lista_especies <- c(
"Triatoma mexicana",
"Triatoma barberi",
"Dipetalogaster maxima",
"Meccus longipennis",
"Meccus pallidipennis",
"Baiomys musculus",
"Neotoma mexicana"
)
resultados_sdm <- list()
for (nombre in lista_especies) {
tryCatch({
cat("\n--- Iniciando:", nombre, " (Nacional) ---\n")
# 1. Descargar datos de GBIF
datos_gbif_crudos <- occ_search(
scientificName = nombre,
hasCoordinate = TRUE,
hasGeospatialIssue = FALSE
)$data
# 2. Verificación de seguridad
if (is.null(datos_gbif_crudos)) {
stop("La descarga de GBIF para esta especie no arrojó ningún dato.")
}
# 3. Llamar a la función de modelado
mapa_proyeccion <- modelar_especie_sdm(
datos_especie_crudos = datos_gbif_crudos,
nombre_cientifico = nombre,
my_bioclim_rasters = my_bioclim_rasters
)
# 4. Almacenar el mapa de proyección final
resultados_sdm[[nombre]] <- mapa_proyeccion
cat(paste("PROCESO COMPLETO y guardado para:", nombre, "\n"))
}, error = function(e) {
cat(paste("!!! ERROR al procesar", nombre, ":", conditionMessage(e), "\n"))
})
}
load("D:/Introducción a R/Proyecto_final/AG1.RData")
load("D:/Introducción a R/Proyecto_final/AG1.RData")
